package io.github.groupease.restendpoint;

import javax.annotation.Nonnull;
import javax.inject.Provider;
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;

import com.codahale.metrics.annotation.Timed;
import javax.inject.Inject;

import com.google.inject.persist.Transactional;
import io.github.groupease.auth.CurrentUserId;
import io.github.groupease.db.GroupDao;
import io.github.groupease.db.GroupeaseUserDao;
import io.github.groupease.exception.*;
import io.github.groupease.model.Group;
import io.github.groupease.model.Member;
import io.github.groupease.model.GroupeaseUser;
import io.github.groupease.user.UserNotFoundException;
import io.github.groupease.util.GroupCreateWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.invoke.MethodHandles;
import java.util.List;

/**
 * REST-ful web service for {@link Group} instances.
 */
@Path("channels/{channelId}/groups")
@Produces(MediaType.APPLICATION_JSON)
public class GroupWebService {
    private static final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());

    private final GroupDao groupDao;
    private final GroupeaseUserDao userDao;
    private final Provider<String> currentUserIdProvider;
    private GroupeaseUser currentUser;

    @Inject
    public GroupWebService(@Nonnull GroupDao groupDao, @Nonnull GroupeaseUserDao userDao,
                           @Nonnull @CurrentUserId Provider<String> currentUserIdProvider)
    {
        this.groupDao = groupDao;
        this.userDao = userDao;
        this.currentUserIdProvider = currentUserIdProvider;
    }

    /**
     * Gets a list of all {@link Group}s in the channel. User must be a member of the channel to retrieve the list
     * @param channelId The ID of the channel to get the list of groups in
     * @return The list of groups. An empty list is returned if there are no groups
     */
    @GET
    @Timed
    @Nonnull
    public List<Group> list(@PathParam("channelId") long channelId)
    {
        LOGGER.debug("GroupWebService.list({})", channelId);

        // Make sure that caller is a member of channel
        verifyCurrentUserIsChannelMember(channelId);

        return groupDao.list(channelId);
    }

    /**
     * Retrieves a specific {@link Group} in a channel. Only channel members can retrieve a group
     * @param channelId The ID of the channel the group is in
     * @param groupId The ID of the group
     * @return The specified group
     */
    @GET
    @Path("{groupId}")
    @Timed
    @Nonnull
    public Group getById(@PathParam("channelId") long channelId, @PathParam("groupId") long groupId)
    {
        LOGGER.debug("GroupWebService.getById(channel={}, group={})", channelId, groupId);

        // Make sure that caller is a member of channel
        verifyCurrentUserIsChannelMember(channelId);

        // Get the group from the database. Verify that it belongs to the specified channel before returning it
        Group group = groupDao.get(groupId);
        if(group == null || group.getChannelId() != channelId)
        {
            throw new GroupNotFoundException();
        }

        return group;
    }

    /**
     * Creates a new {@link Group} in the channel. Only channel members can create a group
     * @param channelId The ID of the channel to create the group in
     * @param newGroup A {@link Group} that contains the group name and other POSTed JSON values
     * @return The newly created group
     */
    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    public Group create(@PathParam("channelId") long channelId, @Nonnull Group newGroup)
    {
        LOGGER.debug("GroupWebService.create(channelUrl={}, name={})", channelId, newGroup.getName());

        // Make sure that caller is a member of channel
        verifyCurrentUserIsChannelMember(channelId);

        // The caller must not supply an ID. One will be generated by the database
        if(newGroup.getId() != null)
        {
            throw new GroupIdMismatchException("No group ID should be supplied in the POSTed data");
        }

        // The channel ID must match the URL
        if(channelId != newGroup.getChannelId())
        {
            throw new ChannelIdMismatchException("The channelId supplied in the POSTed data must match the channel ID in the URL");
        }

        // A group name must be supplied
        if(newGroup.getName() == null || newGroup.getName().isEmpty())
        {
            throw new GroupNameMissingException();
        }

        // Check if a group with this name already exists in the channel
        if(groupDao.get(newGroup.getName(), channelId) != null)
        {
            throw new GroupNameConflictException();
        }

        // Find the user's member object so it can be added to the new group
        Member currentUserMember = currentUser.getMemberList().stream()
                .filter(member -> member.getChannel().getId() == channelId).findFirst().get();

        return groupDao.create(channelId, newGroup.getName(), newGroup.getDescription(), currentUserMember);
    }

    /**
     * Updates a {@link Group}
     * @param channelId The ID of the channel the group is part of
     * @param groupId The ID of the group
     * @param updateGroup The {@link Group} object that contains the uploaded JSON wrapped fields
     * @return The revised group object
     */
    @PUT
    @Path("{groupId}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Transactional
    public Group update(@PathParam("channelId") long channelId, @PathParam("groupId") long groupId,
                        @Nonnull Group updateGroup)
    {
        LOGGER.debug("GroupWebService.update(channelUrl={}, groupIdUrl={}, JSON={})", channelId, groupId, updateGroup.toString());

        // Make sure that caller is a member of channel
        verifyCurrentUserIsChannelMember(channelId);

        // The caller must supply an ID of an existing group
        if(updateGroup.getId() == null)
        {
            throw new GroupIdMismatchException("JSON group ID must be supplied");
        }
        if(updateGroup.getId() != groupId)
        {
            throw new GroupIdMismatchException("JSON group ID " + updateGroup.getId() + "must match group ID " + groupId + " in URL");
        }

        // The channel ID must be supplied and it must match the URL
        /*if(updateGroup.getChannelId() == null)
        {
            throw new ChannelIdMismatchException("The channel ID must be supplied in the JSON");
        }*/
        if(channelId != updateGroup.getChannelId())
        {
            throw new ChannelIdMismatchException("JSON channel ID " + updateGroup.getChannelId() +
                    " must match the channel ID " + channelId + " in the URL");
        }

        // A group name must be supplied and not empty
        if(updateGroup.getName() == null || updateGroup.getName().isEmpty())
        {
            throw new GroupNameMissingException("A group name must be supplied");
        }

        // Check if a group with this new name already exists in the channel
        Group sameNameGroup = groupDao.get(updateGroup.getName(), channelId);
        if(sameNameGroup != null && sameNameGroup.getId() != groupId)
        {
            throw new GroupNameConflictException("Cannot rename group because there is already a group with that name");
        }

        // Get the existing group
        Group existingGroup = groupDao.get(updateGroup.getId());
        if(existingGroup == null)
        {
            throw new GroupNotFoundException("The group with the specified ID in the specified channel could not be found");
        }

        // Updates should only be allowed by a member of the group
        if(existingGroup.getMembers().stream()
                .noneMatch(member->member.getGroupeaseUser().getId().equals(currentUser.getId())))
        {
            throw new NotGroupMemberException("Only group members can make changes to a group");
        }

        // Look at the POSTed members list. If the members list is empty, we'll just try updating the name
        // and description. If the members list supplied isn't empty, then we need to investigate it. The
        // only change allowed is for the user to remove himself (leave the group)
        if(updateGroup.getMembers().isEmpty())
        {
            LOGGER.debug("GroupWebService.update *** No JSON member list so updating name and description only");
            existingGroup.setName(updateGroup.getName());
            existingGroup.setDescription(updateGroup.getDescription());
        }
        else
        {
            for(int i=0; i<updateGroup.getMembers().size(); i++)
            {
                LOGGER.debug("GroupWebService.update *** Member array[{}] - id: {}, name: {}",
                        i, updateGroup.getMembers().get(i).getGroupeaseUser().getId(),
                        updateGroup.getMembers().get(i).getGroupeaseUser().getName());
            }
            // If the submitted membership list is bigger its clearly illegal
            if(updateGroup.getMembers().size() > existingGroup.getMembers().size())
            {
                throw new InvalidGroupModificationException(
                        "The only change to the group membership allowed is to remove yourself");
            }
            else if(updateGroup.getMembers().size() == existingGroup.getMembers().size() - 1)
            {
                LOGGER.debug("GroupWebService.update *** currentUser.id: {}", currentUser.getId());
                if(updateGroup.getMembers()
                        .stream().anyMatch(member -> member.getGroupeaseUser().getId().equals(currentUser.getId())))
                {
                    // The submitted list is smaller than the database list but the current user is still in the list
                    // Obvious attempt to try and remove someone else
                    throw new InvalidGroupModificationException(
                            "The only change to the group membership allowed is to remove yourself");
                }

                LOGGER.debug("GroupWebService.update *** JSON member list 1 smaller than database list. Removing caller");

                // Should probably verify that the remainder are the same in both lists, but for now just
                // go ahead and remove the current user
                existingGroup.setName(updateGroup.getName());
                existingGroup.setDescription(updateGroup.getDescription());
                existingGroup.getMembers().remove(existingGroup.getMembers().stream()
                        .filter(member -> member.getGroupeaseUser().equals(currentUser)).findFirst().get());
                groupDao.merge(existingGroup);
            }
            else if(updateGroup.getMembers().size() < existingGroup.getMembers().size() - 1)
            {
                LOGGER.debug("GroupWebService.update *** JSON member list 2 or more smaller than database list. Throw!");
                throw new InvalidGroupModificationException(
                        "The only change to the group membership allowed is to remove yourself");
            }
            else
            {
                // Same size list. For now, just check that the membership IDs are the same
                // Probably should come back later and add more detailed checks, but time-crunch
                for (int i = 0; i < existingGroup.getMembers().size(); i++) {
                    GroupeaseUser temp = existingGroup.getMembers().get(i).getGroupeaseUser();
                    if(updateGroup.getMembers().stream()
                            .noneMatch(member -> member.getGroupeaseUser().getId()
                                    .equals(temp.getId())))
                    {
                        LOGGER.debug("GroupWebService.update *** JSON member list size equals database list but database member not in JSON. Throw!");
                        throw new InvalidGroupModificationException(
                                "The only change to the group membership allowed is to remove yourself");
                    }
                }
                existingGroup.setName(updateGroup.getName());
                existingGroup.setDescription(updateGroup.getDescription());
            }
        }

        return existingGroup;
    }

    // Helper method that ensures that the logged on user is a channel member and therefore has permission
    // to perform operations on group objects.
    private void verifyCurrentUserIsChannelMember(long channelId)
    {
        currentUser = userDao.getByProviderId(currentUserIdProvider.get());
        if(currentUser == null)
        {
            // No profile for the user was found in the database so can't possibly be a channel member
            // Throwing specific user not found exception. Should consider whether it would just be better
            // to create a profile and then throwing the more general not channel member exception
            throw new UserNotFoundException("There is no profile found for the current user");
        }

        if(currentUser.getMemberList().stream().noneMatch(member -> member.getChannel().getId() == channelId))
        {
            throw new NotChannelMemberException();
        }
    }
}
